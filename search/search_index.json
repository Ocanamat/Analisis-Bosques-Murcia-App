{"config":{"lang":["en","es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"20250306-CascadeResponse-Plottingflow/","title":"20250306 CascadeResponse Plottingflow","text":"<p>[!NOTE] ok. So here is the status of the development: 1. the user loads an excel file, selects which sheets are to be joined, and clicks ok and the ui moves to the graph constructor tab 2. in the graph constructor the user drags and drops variables onto grammar of graphics features, so that the can be visualized in real time on a pyqtgraph drawn onto the plot_widget qtwidget. what is your proposed solution steps to add a dynamic graph(could be bars, could be a histogram, depends on what the user chooses on the constructor tab), map the grammar graphics model with the dragged variables onto the unified_df and plot the corresponding graph on the plot_widget widget?</p> <p>Based on the current state of development, I'll propose a step-by-step solution to implement the dynamic graphing functionality that connects the unified dataframe with the grammar of graphics model and renders plots using [[PyQtGraph]]. Here's my proposed approach:</p>"},{"location":"20250306-CascadeResponse-Plottingflow/#solution-steps-for-dynamic-graphing","title":"Solution Steps for Dynamic Graphing","text":""},{"location":"20250306-CascadeResponse-Plottingflow/#1-set-up-pyqtgraph-in-the-refactored-main-window","title":"1. Set Up PyQtGraph in the Refactored Main Window","text":"<p>First, we need to initialize PyQtGraph in the refactored main window:</p> <ul> <li>Add PyQtGraph imports</li> <li>Initialize the plot widget</li> <li>Configure plot settings (background, grid, legend)</li> <li>Add the plot widget to the plot_widget container</li> </ul>"},{"location":"20250306-CascadeResponse-Plottingflow/#2-create-a-plot-controller","title":"2. Create a Plot Controller","text":"<p>Create a dedicated controller to manage the plotting logic:</p> <ul> <li>Handle the connection between grammar model and data model</li> <li>Process user selections from the grammar constructor</li> <li>Generate appropriate plots based on selected variables and grammar elements</li> <li>Update plots when selections change</li> </ul>"},{"location":"20250306-CascadeResponse-Plottingflow/#3-implement-grammar-to-plot-mapping","title":"3. Implement Grammar-to-Plot Mapping","text":"<p>Create a mapping system that translates [[grammar of graphics]] concepts to PyQtGraph elements:</p> <ul> <li>Map aesthetics (color, size, shape) to PyQtGraph styling options</li> <li>Map geoms (bar, line, scatter) to appropriate PyQtGraph plot types</li> <li>Map facets to subplot arrangements</li> <li>Handle scales and coordinate systems</li> </ul>"},{"location":"20250306-CascadeResponse-Plottingflow/#4-implement-variable-drag-and-drop-functionality","title":"4. Implement Variable Drag-and-Drop Functionality","text":"<p>Enhance the existing drag-and-drop system to:</p> <ul> <li>Allow variables from the unified dataframe to be dragged to grammar elements</li> <li>Update the grammar model when variables are assigned</li> <li>Trigger plot updates when assignments change</li> </ul>"},{"location":"20250306-CascadeResponse-Plottingflow/#5-create-plot-generation-logic","title":"5. Create Plot Generation Logic","text":"<p>Implement the core plotting logic:</p> <ul> <li>Extract relevant data from the unified dataframe based on selected variables</li> <li>Apply appropriate transformations based on grammar specifications</li> <li>Generate the correct plot type (bar, line, scatter, etc.)</li> <li>Handle aggregations and grouping as needed</li> </ul>"},{"location":"20250306-CascadeResponse-Plottingflow/#6-add-real-time-plot-updates","title":"6. Add Real-time Plot Updates","text":"<p>Ensure plots update in real-time:</p> <ul> <li>Connect signals from the grammar model to the plot controller</li> <li>Implement efficient update mechanisms to avoid full redraws when possible</li> <li>Add animation for transitions between plot states</li> </ul>"},{"location":"20250306-CascadeResponse-Plottingflow/#7-implement-plot-interaction-features","title":"7. Implement Plot Interaction Features","text":"<p>Add interactive features to the plots:</p> <ul> <li>Zooming and panning</li> <li>Data point inspection (tooltips)</li> <li>Legend toggling</li> <li>Export options</li> </ul>"},{"location":"Development%20Notes/","title":"Development Notes","text":""},{"location":"Development%20Notes/#suggestions-and-train-of-thoughts","title":"Suggestions and train of thoughts","text":"<ul> <li>Connecting the unified_df to the grammarGraph-model and plotting it [[20250306-CascadeResponse-Plottingflow]]</li> </ul>"},{"location":"api/models/","title":"Models API Reference","text":"<p>This section documents the model classes used in the Forest Dashboard application.</p>"},{"location":"api/models/#plot-model","title":"Plot Model","text":"<p>The Plot Model handles creating and updating plots based on the grammar of graphics state.</p> <pre><code>from bosques_app.models.plot_model import PlotModel\n</code></pre>"},{"location":"api/models/#bosques_app.models.plot_model.PlotModel","title":"<code>PlotModel</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Model for creating and updating plots based on grammar of graphics state</p> Source code in <code>src\\bosques_app\\models\\plot_model.py</code> <pre><code>class PlotModel(QObject):\n    \"\"\"Model for creating and updating plots based on grammar of graphics state\"\"\"\n\n    # Signal emitted when the plot is updated\n    plot_updated = pyqtSignal()\n\n    def __init__(self, plot_widget: pg.PlotWidget):\n        super().__init__()\n        self.plot_widget = plot_widget\n        self.logger = Logger(\"PlotModel\")\n\n        # Initialize plot items\n        self.plot_items = []\n\n        # Set up plot widget\n        self._setup_plot_widget()\n\n    def _setup_plot_widget(self):\n        \"\"\"Set up the plot widget with default settings\"\"\"\n        # Set background to white\n        self.plot_widget.setBackground('w')\n\n        # Add grid\n        self.plot_widget.showGrid(x=True, y=True, alpha=0.3)\n\n        # Set up axes labels with larger font\n        font = {'color': 'k', 'size': '12pt'}\n        self.plot_widget.getAxis('bottom').setLabel(text='', **font)\n        self.plot_widget.getAxis('left').setLabel(text='', **font)\n\n        # Enable zooming and panning\n        self.plot_widget.setMouseEnabled(x=True, y=True)  # Enable panning by dragging\n        self.plot_widget.enableAutoRange()  # Auto-range initially\n        self.plot_widget.setAutoVisible(y=True)  # Auto-visible for y-axis\n\n        # Enable rectangle zooming\n        viewbox = self.plot_widget.getPlotItem().getViewBox()\n        viewbox.setMouseMode(pg.ViewBox.RectMode)  # Enable rectangle zooming\n\n        # Disable right-click menu for now\n        self.plot_widget.setMenuEnabled(False)\n\n        # Mouse coordinate tracking and tooltips disabled for now\n        self.mouse_coords_label = None  # Will be set from the controller\n\n        # Debug info\n        self.logger.info(f\"Plot widget initialized with size: {self.plot_widget.size()}\")\n\n        # Set up legend with interactive capabilities\n        self.legend = self.plot_widget.addLegend()\n        self.legend_items = {}  # To track legend items for toggling\n\n        # Store original dataframe for tooltips\n        self.current_df = None\n\n    def _reset_plot_view(self):\n        \"\"\"Reset the plot view to default\"\"\"\n        self.plot_widget.autoRange()\n        self.logger.info(\"Vista del gr\u00e1fico restablecida\")\n\n    def update_plot(self, grammar_state: Dict[str, Optional[str]], dataframe: pd.DataFrame):\n        \"\"\"Update the plot based on grammar state and dataframe\n\n        Args:\n            grammar_state: Dictionary mapping aesthetic properties to variable names\n            dataframe: Pandas dataframe containing the data to plot\n        \"\"\"\n        # Clear existing plot items\n        self._clear_plot()\n\n        # Store current dataframe and grammar state for tooltips and interactions\n        self.current_df = dataframe.copy()\n        self.current_grammar_state = grammar_state.copy()\n\n        # Check if we have data and necessary mappings\n        if dataframe is None or dataframe.empty:\n            self.logger.warning(\"No hay datos disponibles para graficar\")\n            return\n\n        # Get x and y mappings (required for plotting)\n        x_var = grammar_state.get('x')\n        y_var = grammar_state.get('y')\n\n        if not x_var or not y_var:\n            self.logger.info(\"Mapeo de X o Y no establecido, no se puede crear el gr\u00e1fico\")\n            return\n\n        # Check if variables exist in dataframe\n        if x_var not in dataframe.columns or y_var not in dataframe.columns:\n            missing = []\n            if x_var not in dataframe.columns:\n                missing.append(f\"X variable '{x_var}'\")\n            if y_var not in dataframe.columns:\n                missing.append(f\"Y variable '{y_var}'\")\n            self.logger.warning(f\"Variables faltantes en el dataframe: {', '.join(missing)}\")\n            return\n\n        # Get other aesthetic mappings\n        color_var = grammar_state.get('color')\n        size_var = grammar_state.get('size')\n        alpha_var = grammar_state.get('alpha')\n\n        # Always ensure we have a plot type, defaulting to 'Dispersi\u00f3n' if not set\n        plot_type = grammar_state.get('plot_type')\n        if not plot_type:\n            plot_type = 'Dispersi\u00f3n'\n            self.logger.info(f\"Tipo de gr\u00e1fico no especificado, usando {plot_type} por defecto\")\n\n        # Create a working copy of the dataframe\n        plot_df = dataframe.copy()\n\n        # Handle datetime conversion for x and y variables\n        self._convert_datetime_columns(plot_df, [x_var, y_var])\n\n        # Set axis labels\n        self.plot_widget.getAxis('bottom').setLabel(text=x_var)\n        self.plot_widget.getAxis('left').setLabel(text=y_var)\n\n        # Create plot based on type\n        if plot_type == 'Dispersi\u00f3n':\n            self._create_scatter_plot(plot_df, x_var, y_var, color_var, size_var, alpha_var)\n        elif plot_type == 'L\u00edneas':\n            self._create_line_plot(plot_df, x_var, y_var, color_var)\n        elif plot_type == 'Barras':\n            self._create_bar_plot(plot_df, x_var, y_var, color_var)\n        elif plot_type is None:\n            # This should never happen now, but just in case\n            self.logger.warning(\"Tipo de gr\u00e1fico es None, usando gr\u00e1fico de dispersi\u00f3n por defecto\")\n            self._create_scatter_plot(plot_df, x_var, y_var, color_var, size_var, alpha_var)\n        else:\n            self.logger.warning(f\"Tipo de gr\u00e1fico '{plot_type}' a\u00fan no implementado\")\n\n        # Connect legend items to click events for toggling visibility\n        self._connect_legend_toggling()\n\n        # Emit signal that plot has been updated\n        self.plot_updated.emit()\n\n    def _clear_plot(self):\n        \"\"\"Clear all plot items\"\"\"\n        self.plot_widget.clear()\n        self.plot_items = []\n        self.legend_items = {}\n\n        # Re-add legend\n        self.legend = self.plot_widget.addLegend()\n\n        # Connect legend item clicks for toggling visibility\n        # This needs to be done after items are added to the legend\n        # We'll connect this in the update_plot method after all items are added\n\n    def _convert_datetime_columns(self, df: pd.DataFrame, columns: List[str]):\n        \"\"\"Convert datetime columns to timestamps for plotting\n\n        Args:\n            df: Dataframe to modify (in-place)\n            columns: List of column names to check and convert if they are datetime\n        \"\"\"\n        for col in columns:\n            if col in df.columns:\n                # Check if column contains datetime-like strings\n                if df[col].dtype == 'object':\n                    try:\n                        # Try to convert to datetime\n                        temp_series = pd.to_datetime(df[col])\n\n                        # If successful, convert to timestamp (seconds since epoch)\n                        df[col] = temp_series.astype('int64') // 10**9\n\n                        # Create custom time axis if this is the first datetime column we find\n                        if not hasattr(self, 'time_axis_set') or not self.time_axis_set:\n                            self.logger.info(f\"Configurando eje de tiempo para {col}\")\n                            axis = self.plot_widget.getAxis('bottom') if col == columns[0] else self.plot_widget.getAxis('left')\n                            axis.setLabel(text=col)\n                            axis.setStyle(tickFont=pg.Qt.QtGui.QFont('Arial', 8))\n\n                            # Create a function to format timestamps as dates\n                            def timestamp_to_date(timestamp):\n                                try:\n                                    dt = datetime.datetime.fromtimestamp(timestamp)\n                                    return dt.strftime('%Y-%m-%d')\n                                except:\n                                    return ''\n\n                            # Set the tick formatter\n                            axis.tickFormatter = timestamp_to_date\n                            self.time_axis_set = True\n\n                        self.logger.info(f\"Convertido {col} de datetime a timestamp para graficar\")\n                    except Exception as e:\n                        self.logger.warning(f\"Error al convertir {col} a datetime: {str(e)}\")\n\n        return df\n\n    def _create_scatter_plot(self, df: pd.DataFrame, x_var: str, y_var: str, \n                            color_var: Optional[str] = None, \n                            size_var: Optional[str] = None,\n                            alpha_var: Optional[str] = None):\n        \"\"\"Create a scatter plot\n\n        Args:\n            df: Dataframe containing the data\n            x_var: Variable to map to x-axis\n            y_var: Variable to map to y-axis\n            color_var: Variable to map to color (optional)\n            size_var: Variable to map to size (optional)\n            alpha_var: Variable to map to transparency (optional)\n        \"\"\"\n        # Default scatter plot settings\n        symbol_size = 10\n        symbol = 'o'\n\n        # If no grouping variable, create a single scatter plot\n        if not color_var:\n            # Get data\n            x_data = df[x_var].values\n            y_data = df[y_var].values\n\n            # Check if data is numeric\n            if not np.issubdtype(x_data.dtype, np.number):\n                self.logger.warning(f\"Variable X '{x_var}' contiene datos no num\u00e9ricos: {x_data[0]}\")\n                try:\n                    x_data = x_data.astype(float)\n                except ValueError:\n                    self.logger.error(f\"No se pueden graficar datos no num\u00e9ricos para el eje X: {x_var}\")\n                    return\n\n            if not np.issubdtype(y_data.dtype, np.number):\n                self.logger.warning(f\"Variable Y '{y_var}' contiene datos no num\u00e9ricos: {y_data[0]}\")\n                try:\n                    y_data = y_data.astype(float)\n                except ValueError:\n                    self.logger.error(f\"No se pueden graficar datos no num\u00e9ricos para el eje Y: {y_var}\")\n                    return\n\n            # Handle size mapping\n            if size_var and size_var in df.columns:\n                # Normalize size values between 5 and 20\n                size_data = df[size_var].values\n                if np.issubdtype(size_data.dtype, np.number):\n                    min_val, max_val = size_data.min(), size_data.max()\n                    if min_val != max_val:\n                        normalized_sizes = 5 + 15 * (size_data - min_val) / (max_val - min_val)\n                        scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=normalized_sizes, \n                                                    pen=None, brush=QColor(0, 114, 189, 150))\n                    else:\n                        scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=symbol_size, \n                                                    pen=None, brush=QColor(0, 114, 189, 150))\n                else:\n                    self.logger.warning(f\"Variable de tama\u00f1o '{size_var}' no es num\u00e9rica\")\n                    scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=symbol_size, \n                                                pen=None, brush=QColor(0, 114, 189, 150))\n            else:\n                scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=symbol_size, \n                                            pen=None, brush=QColor(0, 114, 189, 150))\n\n            # Tooltip functionality disabled for now\n            # Will be implemented in a future update\n\n            # Add scatter to plot\n            self.plot_widget.addItem(scatter)\n            self.plot_items.append(scatter)\n\n        else:\n            # Group by color variable\n            if color_var in df.columns:\n                # Get unique values of color variable\n                color_values = df[color_var].unique()\n\n                # Color palette (using standard colors)\n                colors = [\n                    QColor(0, 114, 189),  # blue\n                    QColor(217, 83, 25),   # orange\n                    QColor(237, 177, 32),  # yellow\n                    QColor(126, 47, 142),  # purple\n                    QColor(119, 172, 48),  # green\n                    QColor(77, 190, 238),  # light blue\n                    QColor(162, 20, 47)    # dark red\n                ]\n\n                # Create scatter plot for each group\n                for i, value in enumerate(color_values):\n                    # Get data for this group\n                    group_df = df[df[color_var] == value]\n                    x_data = group_df[x_var].values\n                    y_data = group_df[y_var].values\n\n                    # Check if data is numeric\n                    if not np.issubdtype(x_data.dtype, np.number):\n                        self.logger.warning(f\"Variable X '{x_var}' en grupo de color '{value}' contiene datos no num\u00e9ricos\")\n                        try:\n                            x_data = x_data.astype(float)\n                        except ValueError:\n                            self.logger.error(f\"No se pueden graficar datos no num\u00e9ricos para el eje X en grupo de color '{value}'\")\n                            continue\n\n                    if not np.issubdtype(y_data.dtype, np.number):\n                        self.logger.warning(f\"Variable Y '{y_var}' en grupo de color '{value}' contiene datos no num\u00e9ricos\")\n                        try:\n                            y_data = y_data.astype(float)\n                        except ValueError:\n                            self.logger.error(f\"No se pueden graficar datos no num\u00e9ricos para el eje Y en grupo de color '{value}'\")\n                            continue\n\n                    # Skip empty groups after filtering\n                    if len(x_data) == 0 or len(y_data) == 0:\n                        self.logger.warning(f\"No hay puntos de datos v\u00e1lidos para el grupo de color '{value}'\")\n                        continue\n\n                    # Get color with some transparency\n                    color_idx = i % len(colors)\n                    color = colors[color_idx]\n                    color.setAlpha(150)\n\n                    # Create scatter plot\n                    scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=symbol_size, \n                                                pen=None, brush=color, name=str(value))\n\n                    # Tooltip functionality disabled for now\n                    # Will be implemented in a future update\n\n                    # Add to plot\n                    self.plot_widget.addItem(scatter)\n                    self.plot_items.append(scatter)\n\n                    # Store legend item for toggling\n                    self.legend_items[str(value)] = {\n                        'plot_item': scatter,\n                        'visible': True\n                    }\n            else:\n                self.logger.warning(f\"Variable de color '{color_var}' no encontrada en el dataframe\")\n                # Fall back to single scatter plot\n                self._create_scatter_plot(df, x_var, y_var)\n\n    def _create_line_plot(self, df: pd.DataFrame, x_var: str, y_var: str, color_var: Optional[str] = None):\n        \"\"\"Create a line plot\n\n        Args:\n            df: Dataframe containing the data\n            x_var: Variable to map to x-axis\n            y_var: Variable to map to y-axis\n            color_var: Variable to map to color (optional)\n        \"\"\"\n        # If no grouping variable, create a single line plot\n        if not color_var:\n            # Sort data by x value for proper line connections\n            sorted_df = df.sort_values(by=x_var)\n            x_data = sorted_df[x_var].values\n            y_data = sorted_df[y_var].values\n\n            # Create line plot\n            line = pg.PlotDataItem(x=x_data, y=y_data, pen=QColor(0, 114, 189))\n\n            # Improve hover events for tooltips\n            line.setToolTip('')\n            line.curve.setClickable(True)  # Make line clickable for hover events\n\n            # Create a custom hover event handler that shows tooltips\n            def hover_event_handler(plot_item, points):\n                self._show_point_tooltip(points, x_var, y_var)\n\n            line.sigPointsHovered.connect(hover_event_handler)\n\n            # Make the line more interactive with symbols at data points\n            line.setSymbol('o')  # Show points on the line\n            line.setSymbolSize(7)  # Size of the points\n\n            # Add to plot\n            self.plot_widget.addItem(line)\n            self.plot_items.append(line)\n\n        else:\n            # Group by color variable\n            if color_var in df.columns:\n                # Get unique values of color variable\n                color_values = df[color_var].unique()\n\n                # Color palette (using standard colors)\n                colors = [\n                    QColor(0, 114, 189),  # blue\n                    QColor(217, 83, 25),   # orange\n                    QColor(237, 177, 32),  # yellow\n                    QColor(126, 47, 142),  # purple\n                    QColor(119, 172, 48),  # green\n                    QColor(77, 190, 238),  # light blue\n                    QColor(162, 20, 47)    # dark red\n                ]\n\n                # Create line plot for each group\n                for i, value in enumerate(color_values):\n                    # Get data for this group and sort by x\n                    group_df = df[df[color_var] == value].sort_values(by=x_var)\n                    x_data = group_df[x_var].values\n                    y_data = group_df[y_var].values\n\n                    # Get color\n                    color_idx = i % len(colors)\n                    color = colors[color_idx]\n\n                    # Create line plot\n                    line = pg.PlotDataItem(x=x_data, y=y_data, pen=color, name=str(value))\n\n                    # Improve hover events for tooltips\n                    line.setToolTip('')\n                    line.curve.setClickable(True)  # Make line clickable for hover events\n\n                    # Create a custom hover event handler that shows tooltips\n                    def hover_event_handler(plot_item, points):\n                        self._show_point_tooltip(points, x_var, y_var, color_var=color_var, color_value=value)\n\n                    line.sigPointsHovered.connect(hover_event_handler)\n\n                    # Make the line more interactive with symbols at data points\n                    line.setSymbol('o')  # Show points on the line\n                    line.setSymbolSize(7)  # Size of the points\n\n                    # Add to plot\n                    self.plot_widget.addItem(line)\n                    self.plot_items.append(line)\n\n                    # Store legend item for toggling\n                    self.legend_items[str(value)] = {\n                        'plot_item': line,\n                        'visible': True\n                    }\n            else:\n                self.logger.warning(f\"Variable de color '{color_var}' no encontrada en el dataframe\")\n                # Fall back to single line plot\n                self._create_line_plot(df, x_var, y_var)\n\n    # Tooltip and mouse coordinate tracking functionality has been disabled\n    # These features will be implemented in a future update\n\n    def _connect_legend_toggling(self):\n        \"\"\"Connect legend items to click events for toggling visibility\"\"\"\n        if not hasattr(self, 'legend') or self.legend is None:\n            return\n\n        # PyQtGraph doesn't have a direct way to connect to legend item clicks\n        # We need to use a workaround by finding the legend items and connecting to their clicks\n        try:\n            # Check if the legend has items attribute\n            if not hasattr(self.legend, 'items'):\n                self.logger.debug(\"La leyenda no tiene items para conectar eventos\")\n                return\n\n            # Get the legend's layout items\n            legend_items = self.legend.items\n\n            # For each legend item, connect its label to a click event\n            for item_pair in legend_items:\n                # Check if we have a valid item pair\n                if not isinstance(item_pair, (list, tuple)) or len(item_pair) &lt; 2:\n                    continue\n\n                label, item = item_pair\n\n                # Skip if we don't have a valid label\n                if not hasattr(label, 'mousePressEvent'):\n                    continue\n\n                # Skip if we don't have a valid text property\n                if not hasattr(label, 'text'):\n                    continue\n\n                # Store the original mousePressEvent\n                original_mouse_press = label.mousePressEvent\n\n                # Create a new mousePressEvent that toggles visibility\n                def create_click_handler(name, original_handler):\n                    def click_handler(event):\n                        # Call original handler first\n                        original_handler(event)\n                        # Then toggle the item\n                        self._toggle_legend_item(name)\n                    return click_handler\n\n                # Get the name from the label text\n                name = label.text\n\n                # Set the new mousePressEvent\n                label.mousePressEvent = create_click_handler(name, original_mouse_press)\n\n                # Change cursor to indicate clickable\n                label.setCursor(Qt.CursorShape.PointingHandCursor)\n\n                self.logger.debug(f\"Conectado evento de clic para leyenda '{name}'\")\n        except Exception as e:\n            self.logger.warning(f\"Error al conectar eventos de clic de leyenda: {str(e)}\")\n\n    def _toggle_legend_item(self, legend_name: str):\n        \"\"\"Toggle visibility of a plot item from the legend\n\n        Args:\n            legend_name: Name of the legend item to toggle\n        \"\"\"\n        if legend_name in self.legend_items:\n            item_info = self.legend_items[legend_name]\n            plot_item = item_info['plot_item']\n\n            # Toggle visibility\n            is_visible = item_info['visible']\n            plot_item.setVisible(not is_visible)\n\n            # Update state\n            self.legend_items[legend_name]['visible'] = not is_visible\n\n            self.logger.info(f\"Serie '{legend_name}' {'ocultada' if is_visible else 'mostrada'}\")\n\n    def _create_bar_plot(self, df: pd.DataFrame, x_var: str, y_var: str, color_var: Optional[str] = None):\n        \"\"\"Create a bar plot\n\n        Args:\n            df: Dataframe containing the data\n            x_var: Variable to map to x-axis (categories)\n            y_var: Variable to map to y-axis (values)\n            color_var: Variable to map to color (optional)\n        \"\"\"\n        # For bar plots, we need to aggregate data if x has duplicate values\n        if df[x_var].duplicated().any():\n            # Group by x and calculate mean of y\n            agg_df = df.groupby(x_var)[y_var].mean().reset_index()\n        else:\n            agg_df = df\n\n        # Get unique x values and corresponding y values\n        x_categories = agg_df[x_var].values\n        y_values = agg_df[y_var].values\n\n        # Convert categories to positions if not numeric\n        if not np.issubdtype(agg_df[x_var].dtype, np.number):\n            x_positions = np.arange(len(x_categories))\n            # Create custom axis with category labels\n            ticks = [(i, str(cat)) for i, cat in enumerate(x_categories)]\n            self.plot_widget.getAxis('bottom').setTicks([ticks])\n        else:\n            x_positions = x_categories\n\n        # Create bar plot\n        bar_width = 0.6  # Width of bars\n\n        # If no color variable, use single color for all bars\n        if not color_var:\n            # Create bar graph using BarGraphItem\n            bar_graph = pg.BarGraphItem(x=x_positions, height=y_values, width=bar_width, \n                                       brush=QColor(0, 114, 189, 150))\n\n            # Add to plot\n            self.plot_widget.addItem(bar_graph)\n            self.plot_items.append(bar_graph)\n\n        else:\n            # Not implemented yet - fall back to single color\n            self.logger.warning(\"Gr\u00e1ficos de barras con agrupaci\u00f3n por color a\u00fan no implementados\")\n            self._create_bar_plot(df, x_var, y_var)\n</code></pre>"},{"location":"api/models/#bosques_app.models.plot_model.PlotModel-functions","title":"Functions","text":""},{"location":"api/models/#bosques_app.models.plot_model.PlotModel.update_plot","title":"<code>update_plot(grammar_state, dataframe)</code>","text":"<p>Update the plot based on grammar state and dataframe</p> <p>Parameters:</p> Name Type Description Default <code>grammar_state</code> <code>Dict[str, Optional[str]]</code> <p>Dictionary mapping aesthetic properties to variable names</p> required <code>dataframe</code> <code>DataFrame</code> <p>Pandas dataframe containing the data to plot</p> required Source code in <code>src\\bosques_app\\models\\plot_model.py</code> <pre><code>def update_plot(self, grammar_state: Dict[str, Optional[str]], dataframe: pd.DataFrame):\n    \"\"\"Update the plot based on grammar state and dataframe\n\n    Args:\n        grammar_state: Dictionary mapping aesthetic properties to variable names\n        dataframe: Pandas dataframe containing the data to plot\n    \"\"\"\n    # Clear existing plot items\n    self._clear_plot()\n\n    # Store current dataframe and grammar state for tooltips and interactions\n    self.current_df = dataframe.copy()\n    self.current_grammar_state = grammar_state.copy()\n\n    # Check if we have data and necessary mappings\n    if dataframe is None or dataframe.empty:\n        self.logger.warning(\"No hay datos disponibles para graficar\")\n        return\n\n    # Get x and y mappings (required for plotting)\n    x_var = grammar_state.get('x')\n    y_var = grammar_state.get('y')\n\n    if not x_var or not y_var:\n        self.logger.info(\"Mapeo de X o Y no establecido, no se puede crear el gr\u00e1fico\")\n        return\n\n    # Check if variables exist in dataframe\n    if x_var not in dataframe.columns or y_var not in dataframe.columns:\n        missing = []\n        if x_var not in dataframe.columns:\n            missing.append(f\"X variable '{x_var}'\")\n        if y_var not in dataframe.columns:\n            missing.append(f\"Y variable '{y_var}'\")\n        self.logger.warning(f\"Variables faltantes en el dataframe: {', '.join(missing)}\")\n        return\n\n    # Get other aesthetic mappings\n    color_var = grammar_state.get('color')\n    size_var = grammar_state.get('size')\n    alpha_var = grammar_state.get('alpha')\n\n    # Always ensure we have a plot type, defaulting to 'Dispersi\u00f3n' if not set\n    plot_type = grammar_state.get('plot_type')\n    if not plot_type:\n        plot_type = 'Dispersi\u00f3n'\n        self.logger.info(f\"Tipo de gr\u00e1fico no especificado, usando {plot_type} por defecto\")\n\n    # Create a working copy of the dataframe\n    plot_df = dataframe.copy()\n\n    # Handle datetime conversion for x and y variables\n    self._convert_datetime_columns(plot_df, [x_var, y_var])\n\n    # Set axis labels\n    self.plot_widget.getAxis('bottom').setLabel(text=x_var)\n    self.plot_widget.getAxis('left').setLabel(text=y_var)\n\n    # Create plot based on type\n    if plot_type == 'Dispersi\u00f3n':\n        self._create_scatter_plot(plot_df, x_var, y_var, color_var, size_var, alpha_var)\n    elif plot_type == 'L\u00edneas':\n        self._create_line_plot(plot_df, x_var, y_var, color_var)\n    elif plot_type == 'Barras':\n        self._create_bar_plot(plot_df, x_var, y_var, color_var)\n    elif plot_type is None:\n        # This should never happen now, but just in case\n        self.logger.warning(\"Tipo de gr\u00e1fico es None, usando gr\u00e1fico de dispersi\u00f3n por defecto\")\n        self._create_scatter_plot(plot_df, x_var, y_var, color_var, size_var, alpha_var)\n    else:\n        self.logger.warning(f\"Tipo de gr\u00e1fico '{plot_type}' a\u00fan no implementado\")\n\n    # Connect legend items to click events for toggling visibility\n    self._connect_legend_toggling()\n\n    # Emit signal that plot has been updated\n    self.plot_updated.emit()\n</code></pre>"},{"location":"api/models/#bosques_app.models.plot_model.PlotModel._create_scatter_plot","title":"<code>_create_scatter_plot(df, x_var, y_var, color_var=None, size_var=None, alpha_var=None)</code>","text":"<p>Create a scatter plot</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe containing the data</p> required <code>x_var</code> <code>str</code> <p>Variable to map to x-axis</p> required <code>y_var</code> <code>str</code> <p>Variable to map to y-axis</p> required <code>color_var</code> <code>Optional[str]</code> <p>Variable to map to color (optional)</p> <code>None</code> <code>size_var</code> <code>Optional[str]</code> <p>Variable to map to size (optional)</p> <code>None</code> <code>alpha_var</code> <code>Optional[str]</code> <p>Variable to map to transparency (optional)</p> <code>None</code> Source code in <code>src\\bosques_app\\models\\plot_model.py</code> <pre><code>def _create_scatter_plot(self, df: pd.DataFrame, x_var: str, y_var: str, \n                        color_var: Optional[str] = None, \n                        size_var: Optional[str] = None,\n                        alpha_var: Optional[str] = None):\n    \"\"\"Create a scatter plot\n\n    Args:\n        df: Dataframe containing the data\n        x_var: Variable to map to x-axis\n        y_var: Variable to map to y-axis\n        color_var: Variable to map to color (optional)\n        size_var: Variable to map to size (optional)\n        alpha_var: Variable to map to transparency (optional)\n    \"\"\"\n    # Default scatter plot settings\n    symbol_size = 10\n    symbol = 'o'\n\n    # If no grouping variable, create a single scatter plot\n    if not color_var:\n        # Get data\n        x_data = df[x_var].values\n        y_data = df[y_var].values\n\n        # Check if data is numeric\n        if not np.issubdtype(x_data.dtype, np.number):\n            self.logger.warning(f\"Variable X '{x_var}' contiene datos no num\u00e9ricos: {x_data[0]}\")\n            try:\n                x_data = x_data.astype(float)\n            except ValueError:\n                self.logger.error(f\"No se pueden graficar datos no num\u00e9ricos para el eje X: {x_var}\")\n                return\n\n        if not np.issubdtype(y_data.dtype, np.number):\n            self.logger.warning(f\"Variable Y '{y_var}' contiene datos no num\u00e9ricos: {y_data[0]}\")\n            try:\n                y_data = y_data.astype(float)\n            except ValueError:\n                self.logger.error(f\"No se pueden graficar datos no num\u00e9ricos para el eje Y: {y_var}\")\n                return\n\n        # Handle size mapping\n        if size_var and size_var in df.columns:\n            # Normalize size values between 5 and 20\n            size_data = df[size_var].values\n            if np.issubdtype(size_data.dtype, np.number):\n                min_val, max_val = size_data.min(), size_data.max()\n                if min_val != max_val:\n                    normalized_sizes = 5 + 15 * (size_data - min_val) / (max_val - min_val)\n                    scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=normalized_sizes, \n                                                pen=None, brush=QColor(0, 114, 189, 150))\n                else:\n                    scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=symbol_size, \n                                                pen=None, brush=QColor(0, 114, 189, 150))\n            else:\n                self.logger.warning(f\"Variable de tama\u00f1o '{size_var}' no es num\u00e9rica\")\n                scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=symbol_size, \n                                            pen=None, brush=QColor(0, 114, 189, 150))\n        else:\n            scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=symbol_size, \n                                        pen=None, brush=QColor(0, 114, 189, 150))\n\n        # Tooltip functionality disabled for now\n        # Will be implemented in a future update\n\n        # Add scatter to plot\n        self.plot_widget.addItem(scatter)\n        self.plot_items.append(scatter)\n\n    else:\n        # Group by color variable\n        if color_var in df.columns:\n            # Get unique values of color variable\n            color_values = df[color_var].unique()\n\n            # Color palette (using standard colors)\n            colors = [\n                QColor(0, 114, 189),  # blue\n                QColor(217, 83, 25),   # orange\n                QColor(237, 177, 32),  # yellow\n                QColor(126, 47, 142),  # purple\n                QColor(119, 172, 48),  # green\n                QColor(77, 190, 238),  # light blue\n                QColor(162, 20, 47)    # dark red\n            ]\n\n            # Create scatter plot for each group\n            for i, value in enumerate(color_values):\n                # Get data for this group\n                group_df = df[df[color_var] == value]\n                x_data = group_df[x_var].values\n                y_data = group_df[y_var].values\n\n                # Check if data is numeric\n                if not np.issubdtype(x_data.dtype, np.number):\n                    self.logger.warning(f\"Variable X '{x_var}' en grupo de color '{value}' contiene datos no num\u00e9ricos\")\n                    try:\n                        x_data = x_data.astype(float)\n                    except ValueError:\n                        self.logger.error(f\"No se pueden graficar datos no num\u00e9ricos para el eje X en grupo de color '{value}'\")\n                        continue\n\n                if not np.issubdtype(y_data.dtype, np.number):\n                    self.logger.warning(f\"Variable Y '{y_var}' en grupo de color '{value}' contiene datos no num\u00e9ricos\")\n                    try:\n                        y_data = y_data.astype(float)\n                    except ValueError:\n                        self.logger.error(f\"No se pueden graficar datos no num\u00e9ricos para el eje Y en grupo de color '{value}'\")\n                        continue\n\n                # Skip empty groups after filtering\n                if len(x_data) == 0 or len(y_data) == 0:\n                    self.logger.warning(f\"No hay puntos de datos v\u00e1lidos para el grupo de color '{value}'\")\n                    continue\n\n                # Get color with some transparency\n                color_idx = i % len(colors)\n                color = colors[color_idx]\n                color.setAlpha(150)\n\n                # Create scatter plot\n                scatter = pg.ScatterPlotItem(x=x_data, y=y_data, size=symbol_size, \n                                            pen=None, brush=color, name=str(value))\n\n                # Tooltip functionality disabled for now\n                # Will be implemented in a future update\n\n                # Add to plot\n                self.plot_widget.addItem(scatter)\n                self.plot_items.append(scatter)\n\n                # Store legend item for toggling\n                self.legend_items[str(value)] = {\n                    'plot_item': scatter,\n                    'visible': True\n                }\n        else:\n            self.logger.warning(f\"Variable de color '{color_var}' no encontrada en el dataframe\")\n            # Fall back to single scatter plot\n            self._create_scatter_plot(df, x_var, y_var)\n</code></pre>"},{"location":"api/models/#bosques_app.models.plot_model.PlotModel._create_line_plot","title":"<code>_create_line_plot(df, x_var, y_var, color_var=None)</code>","text":"<p>Create a line plot</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe containing the data</p> required <code>x_var</code> <code>str</code> <p>Variable to map to x-axis</p> required <code>y_var</code> <code>str</code> <p>Variable to map to y-axis</p> required <code>color_var</code> <code>Optional[str]</code> <p>Variable to map to color (optional)</p> <code>None</code> Source code in <code>src\\bosques_app\\models\\plot_model.py</code> <pre><code>def _create_line_plot(self, df: pd.DataFrame, x_var: str, y_var: str, color_var: Optional[str] = None):\n    \"\"\"Create a line plot\n\n    Args:\n        df: Dataframe containing the data\n        x_var: Variable to map to x-axis\n        y_var: Variable to map to y-axis\n        color_var: Variable to map to color (optional)\n    \"\"\"\n    # If no grouping variable, create a single line plot\n    if not color_var:\n        # Sort data by x value for proper line connections\n        sorted_df = df.sort_values(by=x_var)\n        x_data = sorted_df[x_var].values\n        y_data = sorted_df[y_var].values\n\n        # Create line plot\n        line = pg.PlotDataItem(x=x_data, y=y_data, pen=QColor(0, 114, 189))\n\n        # Improve hover events for tooltips\n        line.setToolTip('')\n        line.curve.setClickable(True)  # Make line clickable for hover events\n\n        # Create a custom hover event handler that shows tooltips\n        def hover_event_handler(plot_item, points):\n            self._show_point_tooltip(points, x_var, y_var)\n\n        line.sigPointsHovered.connect(hover_event_handler)\n\n        # Make the line more interactive with symbols at data points\n        line.setSymbol('o')  # Show points on the line\n        line.setSymbolSize(7)  # Size of the points\n\n        # Add to plot\n        self.plot_widget.addItem(line)\n        self.plot_items.append(line)\n\n    else:\n        # Group by color variable\n        if color_var in df.columns:\n            # Get unique values of color variable\n            color_values = df[color_var].unique()\n\n            # Color palette (using standard colors)\n            colors = [\n                QColor(0, 114, 189),  # blue\n                QColor(217, 83, 25),   # orange\n                QColor(237, 177, 32),  # yellow\n                QColor(126, 47, 142),  # purple\n                QColor(119, 172, 48),  # green\n                QColor(77, 190, 238),  # light blue\n                QColor(162, 20, 47)    # dark red\n            ]\n\n            # Create line plot for each group\n            for i, value in enumerate(color_values):\n                # Get data for this group and sort by x\n                group_df = df[df[color_var] == value].sort_values(by=x_var)\n                x_data = group_df[x_var].values\n                y_data = group_df[y_var].values\n\n                # Get color\n                color_idx = i % len(colors)\n                color = colors[color_idx]\n\n                # Create line plot\n                line = pg.PlotDataItem(x=x_data, y=y_data, pen=color, name=str(value))\n\n                # Improve hover events for tooltips\n                line.setToolTip('')\n                line.curve.setClickable(True)  # Make line clickable for hover events\n\n                # Create a custom hover event handler that shows tooltips\n                def hover_event_handler(plot_item, points):\n                    self._show_point_tooltip(points, x_var, y_var, color_var=color_var, color_value=value)\n\n                line.sigPointsHovered.connect(hover_event_handler)\n\n                # Make the line more interactive with symbols at data points\n                line.setSymbol('o')  # Show points on the line\n                line.setSymbolSize(7)  # Size of the points\n\n                # Add to plot\n                self.plot_widget.addItem(line)\n                self.plot_items.append(line)\n\n                # Store legend item for toggling\n                self.legend_items[str(value)] = {\n                    'plot_item': line,\n                    'visible': True\n                }\n        else:\n            self.logger.warning(f\"Variable de color '{color_var}' no encontrada en el dataframe\")\n            # Fall back to single line plot\n            self._create_line_plot(df, x_var, y_var)\n</code></pre>"},{"location":"api/models/#bosques_app.models.plot_model.PlotModel._create_bar_plot","title":"<code>_create_bar_plot(df, x_var, y_var, color_var=None)</code>","text":"<p>Create a bar plot</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe containing the data</p> required <code>x_var</code> <code>str</code> <p>Variable to map to x-axis (categories)</p> required <code>y_var</code> <code>str</code> <p>Variable to map to y-axis (values)</p> required <code>color_var</code> <code>Optional[str]</code> <p>Variable to map to color (optional)</p> <code>None</code> Source code in <code>src\\bosques_app\\models\\plot_model.py</code> <pre><code>def _create_bar_plot(self, df: pd.DataFrame, x_var: str, y_var: str, color_var: Optional[str] = None):\n    \"\"\"Create a bar plot\n\n    Args:\n        df: Dataframe containing the data\n        x_var: Variable to map to x-axis (categories)\n        y_var: Variable to map to y-axis (values)\n        color_var: Variable to map to color (optional)\n    \"\"\"\n    # For bar plots, we need to aggregate data if x has duplicate values\n    if df[x_var].duplicated().any():\n        # Group by x and calculate mean of y\n        agg_df = df.groupby(x_var)[y_var].mean().reset_index()\n    else:\n        agg_df = df\n\n    # Get unique x values and corresponding y values\n    x_categories = agg_df[x_var].values\n    y_values = agg_df[y_var].values\n\n    # Convert categories to positions if not numeric\n    if not np.issubdtype(agg_df[x_var].dtype, np.number):\n        x_positions = np.arange(len(x_categories))\n        # Create custom axis with category labels\n        ticks = [(i, str(cat)) for i, cat in enumerate(x_categories)]\n        self.plot_widget.getAxis('bottom').setTicks([ticks])\n    else:\n        x_positions = x_categories\n\n    # Create bar plot\n    bar_width = 0.6  # Width of bars\n\n    # If no color variable, use single color for all bars\n    if not color_var:\n        # Create bar graph using BarGraphItem\n        bar_graph = pg.BarGraphItem(x=x_positions, height=y_values, width=bar_width, \n                                   brush=QColor(0, 114, 189, 150))\n\n        # Add to plot\n        self.plot_widget.addItem(bar_graph)\n        self.plot_items.append(bar_graph)\n\n    else:\n        # Not implemented yet - fall back to single color\n        self.logger.warning(\"Gr\u00e1ficos de barras con agrupaci\u00f3n por color a\u00fan no implementados\")\n        self._create_bar_plot(df, x_var, y_var)\n</code></pre>"},{"location":"api/models/#bosques_app.models.plot_model.PlotModel._connect_legend_toggling","title":"<code>_connect_legend_toggling()</code>","text":"<p>Connect legend items to click events for toggling visibility</p> Source code in <code>src\\bosques_app\\models\\plot_model.py</code> <pre><code>def _connect_legend_toggling(self):\n    \"\"\"Connect legend items to click events for toggling visibility\"\"\"\n    if not hasattr(self, 'legend') or self.legend is None:\n        return\n\n    # PyQtGraph doesn't have a direct way to connect to legend item clicks\n    # We need to use a workaround by finding the legend items and connecting to their clicks\n    try:\n        # Check if the legend has items attribute\n        if not hasattr(self.legend, 'items'):\n            self.logger.debug(\"La leyenda no tiene items para conectar eventos\")\n            return\n\n        # Get the legend's layout items\n        legend_items = self.legend.items\n\n        # For each legend item, connect its label to a click event\n        for item_pair in legend_items:\n            # Check if we have a valid item pair\n            if not isinstance(item_pair, (list, tuple)) or len(item_pair) &lt; 2:\n                continue\n\n            label, item = item_pair\n\n            # Skip if we don't have a valid label\n            if not hasattr(label, 'mousePressEvent'):\n                continue\n\n            # Skip if we don't have a valid text property\n            if not hasattr(label, 'text'):\n                continue\n\n            # Store the original mousePressEvent\n            original_mouse_press = label.mousePressEvent\n\n            # Create a new mousePressEvent that toggles visibility\n            def create_click_handler(name, original_handler):\n                def click_handler(event):\n                    # Call original handler first\n                    original_handler(event)\n                    # Then toggle the item\n                    self._toggle_legend_item(name)\n                return click_handler\n\n            # Get the name from the label text\n            name = label.text\n\n            # Set the new mousePressEvent\n            label.mousePressEvent = create_click_handler(name, original_mouse_press)\n\n            # Change cursor to indicate clickable\n            label.setCursor(Qt.CursorShape.PointingHandCursor)\n\n            self.logger.debug(f\"Conectado evento de clic para leyenda '{name}'\")\n    except Exception as e:\n        self.logger.warning(f\"Error al conectar eventos de clic de leyenda: {str(e)}\")\n</code></pre>"},{"location":"api/models/#data-model","title":"Data Model","text":"<p>The Data Model handles loading and processing Excel data.</p> <pre><code>from bosques_app.models.data_model import DataModel\n</code></pre>"},{"location":"api/models/#bosques_app.models.data_model.DataModel","title":"<code>DataModel</code>","text":"<p>Model for handling Excel data operations</p> Source code in <code>src\\bosques_app\\models\\data_model.py</code> <pre><code>class DataModel:\n    \"\"\"Model for handling Excel data operations\"\"\"\n\n    # Load variable definitions for column mapping\n    CONFIG_DIR = Path(os.path.dirname(os.path.abspath(__file__))).parent / 'config'\n\n    try:\n        with open(CONFIG_DIR / 'variables.yaml', 'r', encoding='utf-8') as f:\n            _variables_config = yaml.safe_load(f)\n    except Exception as e:\n        _variables_config = {'variables': []}\n        # We'll log this properly once the logger is initialized\n\n    def __init__(self):\n        self.data: Optional[Dict[str, pd.DataFrame]] = None\n        self.filename: Optional[str] = None\n        self.sheet_names: Optional[List[str]] = None\n        self.unified_df: Optional[pd.DataFrame] = None\n        self.logger = Logger.get_instance(\"data_model\")\n\n        # Log any config loading errors that happened before logger was initialized\n        if self._variables_config == {'variables': []}:\n            self.logger.error(\"Error loading variables config\")\n\n    def load_excel(self, filename: str) -&gt; Tuple[bool, str]:\n        \"\"\"Load Excel file and store all sheets\"\"\"\n        try:\n            excel_file = pd.ExcelFile(filename)\n            self.sheet_names = excel_file.sheet_names\n            self.data = pd.read_excel(excel_file, sheet_name=None)\n            self.filename = filename\n            summary = self.get_summary()\n            return True, summary\n        except Exception as e:\n            return False, f\"Error loading Excel file: {str(e)}\"\n\n    def transform_temperatures(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Transform temperature data from wide to long format and aggregate by day\"\"\"\n        melted = pd.melt(\n            df,\n            id_vars=['id', 'year', 'nmes', 'mes', 'Fecha', 'Hora'],\n            var_name='Estacion',\n            value_name='Temperatura'\n        )\n        melted['Temperatura'] = melted['Temperatura'].apply(convert_numeric)\n        melted['Fecha'] = melted['Fecha'].apply(standardize_date)\n\n        # Aggregate by day and station\n        self.logger.info(\"Aggregating temperature data by day\")\n        daily_temps = melted.groupby(['Fecha', 'Estacion']).agg(\n            Temp_Min=('Temperatura', 'min'),\n            Temp_Max=('Temperatura', 'max'),\n            Temp_Mean=('Temperatura', 'mean'),\n            Temp_Count=('Temperatura', 'count')\n        ).reset_index()\n\n        return daily_temps\n\n    def transform_dendrometers(self, df: pd.DataFrame, is_carm: bool = False) -&gt; pd.DataFrame:\n        \"\"\"Transform dendrometer data\"\"\"\n        df = df.copy()\n        station_col = 'CARM' if is_carm else 'Punto'\n        df = df.rename(columns={station_col: 'Estacion'})\n        df['Diam'] = df['Diam'].apply(convert_numeric)\n        df['Fecha'] = df['Fecha'].apply(standardize_date)\n        return df\n\n    def transform_desfronde(self, df: pd.DataFrame, is_carm: bool = False) -&gt; pd.DataFrame:\n        \"\"\"Transform desfronde data\"\"\"\n        df = df.copy()\n        station_col = 'CARM' if is_carm else 'Esfp'\n        df = df.rename(columns={station_col: 'Estacion'})\n        df['MO'] = df['MO'].apply(convert_numeric)\n        df['Fecha'] = df['Fecha'].apply(standardize_date)\n        return df\n\n    def transform_capturas(self, df: pd.DataFrame, is_carm: bool = False) -&gt; pd.DataFrame:\n        \"\"\"Transform capturas data\"\"\"\n        df = df.copy()\n        station_col = 'CARM' if is_carm else 'Esfp'\n        df = df.rename(columns={station_col: 'Estacion'})\n\n        # Standardize dates\n        df['Fecha'] = df['Fecha'].apply(standardize_date)\n\n        # Convert all species columns to numeric and fill NAs\n        species_cols = df.columns.difference(['id', 'Year', 'Mes', 'Nmes', 'Fecha', 'Estacion'])\n        for col in species_cols:\n            df[col] = df[col].apply(convert_numeric)\n            df[col] = df[col].fillna(pd.NA)\n\n        return df\n\n    def _standardize_join_columns(self, df: pd.DataFrame, sheet_name: str) -&gt; pd.DataFrame:\n        \"\"\"Standardize column names for joining based on variables.yaml configuration\"\"\"\n        # Find variables that need to be standardized for joining (Fecha and Estacion)\n        join_columns = {'Fecha': 'Fecha', 'Estacion': 'Estacion'}\n\n        # Look for variables with excel_name that should be standardized\n        for var in self._variables_config['variables']:\n            if 'excel_name' in var and 'name' in var:\n                var_name = var['name']\n                excel_name = var['excel_name']\n\n                # Only process variables that are used for joining\n                if var_name in ['Fecha', 'Estaci\u00f3n']:\n                    join_column = 'Fecha' if var_name == 'Fecha' else 'Estacion'\n\n                    # Handle excel_name as a list or a single value\n                    excel_names = excel_name if isinstance(excel_name, list) else [excel_name]\n\n                    # Check if any of the excel_names are in the dataframe columns\n                    for name in excel_names:\n                        if name in df.columns and join_column not in df.columns:\n                            df = df.rename(columns={name: join_column})\n                            self.logger.info(f\"Renamed '{name}' to '{join_column}' in {sheet_name}\")\n                            break\n\n        return df\n\n    def transform_sheet(self, sheet_name: str, df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Transform a sheet based on its type\"\"\"\n        is_carm = 'CARM' in sheet_name\n\n        # Transform based on sheet type\n        if 'temperaturas' in sheet_name.lower():\n            transformed_df = self.transform_temperatures(df)\n        elif 'dendrometros' in sheet_name.lower():\n            transformed_df = self.transform_dendrometers(df, is_carm)\n        elif 'desfronde' in sheet_name.lower():\n            transformed_df = self.transform_desfronde(df, is_carm)\n        elif 'capturas' in sheet_name.lower():\n            transformed_df = self.transform_capturas(df, is_carm)\n        else:\n            self.logger.warning(f\"Unknown sheet type: {sheet_name}, returning untransformed\")\n            transformed_df = df\n\n        # Standardize column names for joining based on variables.yaml configuration\n        transformed_df = self._standardize_join_columns(transformed_df, sheet_name)\n\n        return transformed_df\n\n    def _drop_unnecessary_columns(self, df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Drop unnecessary columns from dataframe\"\"\"\n        # List of columns to drop (exact matches)\n        columns_to_drop = [\n            'id', 'year', 'nmes', 'mes', 'Year', 'Mes', 'Nmes',\n            'id_ESFP_capturas_trampas_final', 'Year_ESFP_capturas_trampas_final',\n            'Mes_ESFP_capturas_trampas_final', 'Nmes_ESFP_capturas_trampas_final',\n            'id_ESFP_datos_temperaturas_final', 'Year_ESFP_dendrometros_final',\n            'Mes_ESFP_dendrometros_final', 'Nmes_ESFP_dendrometros_final'\n        ]\n\n        # Drop columns that exist in the dataframe\n        cols_to_drop = [col for col in columns_to_drop if col in df.columns]\n        if cols_to_drop:\n            self.logger.info(f\"Dropping columns: {', '.join(cols_to_drop)}\")\n            df = df.drop(columns=cols_to_drop)\n\n        return df\n\n    def _build_column_mapping(self) -&gt; Dict[str, str]:\n        \"\"\"Build mapping dictionary from excel_name to name based on variables.yaml\"\"\"\n        column_mapping = {}\n\n        for var in self._variables_config['variables']:\n            if 'excel_name' in var and 'name' in var:\n                excel_name = var['excel_name']\n                display_name = var['name']\n\n                # Handle excel_name as a list or a single value\n                if isinstance(excel_name, list):\n                    for name in excel_name:\n                        column_mapping[name] = display_name\n                else:\n                    column_mapping[excel_name] = display_name\n\n        self.logger.info(f\"Built column mapping with {len(column_mapping)} entries\")\n        return column_mapping\n\n    def create_unified_dataframe(self, selected_sheets: List[str]) -&gt; Tuple[bool, str]:\n        \"\"\"Create unified dataframe from selected sheets with standardized format\"\"\"\n        if not self.data or not selected_sheets:\n            return False, \"No data loaded or no sheets selected\"\n\n        try:\n            transformed_dfs = {}\n            messages = []\n\n            # Transform each selected sheet\n            for sheet_name in selected_sheets:\n                if sheet_name not in self.data:\n                    messages.append(f\"Sheet {sheet_name} not found in data\")\n                    continue\n\n                df = self.data[sheet_name]\n                transformed_df = self.transform_sheet(sheet_name, df)\n\n                # Verify required columns exist\n                if 'Fecha' not in transformed_df.columns or 'Estacion' not in transformed_df.columns:\n                    messages.append(f\"Warning: Sheet {sheet_name} missing required columns (Fecha, Estacion)\")\n                    continue\n\n                # Drop unnecessary columns before joining\n                transformed_df = self._drop_unnecessary_columns(transformed_df)\n\n                transformed_dfs[sheet_name] = transformed_df\n                messages.append(f\"Transformed {sheet_name}\")\n\n            if not transformed_dfs:\n                return False, \"No valid sheets to process\"\n\n            # Start joining with first sheet\n            base_sheet = selected_sheets[0]\n            self.unified_df = transformed_dfs[base_sheet].copy()\n\n            # Join with remaining sheets\n            for sheet_name in selected_sheets[1:]:\n                if sheet_name not in transformed_dfs:\n                    continue\n\n                df = transformed_dfs[sheet_name]\n\n                # Perform the join on Fecha and Estacion\n                self.unified_df = pd.merge(\n                    self.unified_df,\n                    df,\n                    on=['Fecha', 'Estacion'],\n                    how='outer',\n                    suffixes=(f'_{base_sheet}', f'_{sheet_name}')\n                )\n                messages.append(f\"Joined sheet {sheet_name} on Fecha and Estacion\")\n\n            # Drop any unnecessary columns that might have been created during join\n            self.unified_df = self._drop_unnecessary_columns(self.unified_df)\n\n            # Rename columns based on mapping from excel_name to name\n            column_mapping = self._build_column_mapping()\n            # Create a mapping dict with only the columns that exist in the dataframe\n            actual_mapping = {col: column_mapping[col] for col in self.unified_df.columns \n                             if col in column_mapping}\n\n            if actual_mapping:\n                self.unified_df = self.unified_df.rename(columns=actual_mapping)\n                mapped_cols = \", \".join([f\"{old} \u2192 {new}\" for old, new in actual_mapping.items()])\n                messages.append(f\"Renamed columns: {mapped_cols}\")\n\n            # Good place for a breakpoint to inspect self.unified_df\n            summary = \"\\n\".join(messages)\n            return True, f\"Successfully transformed and joined sheets:\\n{summary}\"\n\n        except Exception as e:\n            return False, f\"Error processing sheets: {str(e)}\"\n\n    def get_summary(self) -&gt; str:\n        \"\"\"Get summary of loaded data\"\"\"\n        if not self.data:\n            return \"No data loaded\"\n\n        summary = [f\"File: {self.filename}\"]\n        summary.append(f\"Number of sheets: {len(self.sheet_names)}\")\n        summary.append(\"\\nAvailable sheets:\")\n\n        for name, df in self.data.items():\n            summary.append(f\"\\n{name}:\")\n            summary.append(f\"- Rows: {df.shape[0]}\")\n            summary.append(f\"- Columns: {df.shape[1]}\")\n            summary.append(f\"- Columns: {', '.join(df.columns)}\")\n\n        return \"\\n\".join(summary)\n</code></pre>"},{"location":"api/models/#bosques_app.models.data_model.DataModel-functions","title":"Functions","text":""},{"location":"api/models/#bosques_app.models.data_model.DataModel.load_excel","title":"<code>load_excel(filename)</code>","text":"<p>Load Excel file and store all sheets</p> Source code in <code>src\\bosques_app\\models\\data_model.py</code> <pre><code>def load_excel(self, filename: str) -&gt; Tuple[bool, str]:\n    \"\"\"Load Excel file and store all sheets\"\"\"\n    try:\n        excel_file = pd.ExcelFile(filename)\n        self.sheet_names = excel_file.sheet_names\n        self.data = pd.read_excel(excel_file, sheet_name=None)\n        self.filename = filename\n        summary = self.get_summary()\n        return True, summary\n    except Exception as e:\n        return False, f\"Error loading Excel file: {str(e)}\"\n</code></pre>"},{"location":"api/models/#bosques_app.models.data_model.DataModel.create_unified_dataframe","title":"<code>create_unified_dataframe(selected_sheets)</code>","text":"<p>Create unified dataframe from selected sheets with standardized format</p> Source code in <code>src\\bosques_app\\models\\data_model.py</code> <pre><code>def create_unified_dataframe(self, selected_sheets: List[str]) -&gt; Tuple[bool, str]:\n    \"\"\"Create unified dataframe from selected sheets with standardized format\"\"\"\n    if not self.data or not selected_sheets:\n        return False, \"No data loaded or no sheets selected\"\n\n    try:\n        transformed_dfs = {}\n        messages = []\n\n        # Transform each selected sheet\n        for sheet_name in selected_sheets:\n            if sheet_name not in self.data:\n                messages.append(f\"Sheet {sheet_name} not found in data\")\n                continue\n\n            df = self.data[sheet_name]\n            transformed_df = self.transform_sheet(sheet_name, df)\n\n            # Verify required columns exist\n            if 'Fecha' not in transformed_df.columns or 'Estacion' not in transformed_df.columns:\n                messages.append(f\"Warning: Sheet {sheet_name} missing required columns (Fecha, Estacion)\")\n                continue\n\n            # Drop unnecessary columns before joining\n            transformed_df = self._drop_unnecessary_columns(transformed_df)\n\n            transformed_dfs[sheet_name] = transformed_df\n            messages.append(f\"Transformed {sheet_name}\")\n\n        if not transformed_dfs:\n            return False, \"No valid sheets to process\"\n\n        # Start joining with first sheet\n        base_sheet = selected_sheets[0]\n        self.unified_df = transformed_dfs[base_sheet].copy()\n\n        # Join with remaining sheets\n        for sheet_name in selected_sheets[1:]:\n            if sheet_name not in transformed_dfs:\n                continue\n\n            df = transformed_dfs[sheet_name]\n\n            # Perform the join on Fecha and Estacion\n            self.unified_df = pd.merge(\n                self.unified_df,\n                df,\n                on=['Fecha', 'Estacion'],\n                how='outer',\n                suffixes=(f'_{base_sheet}', f'_{sheet_name}')\n            )\n            messages.append(f\"Joined sheet {sheet_name} on Fecha and Estacion\")\n\n        # Drop any unnecessary columns that might have been created during join\n        self.unified_df = self._drop_unnecessary_columns(self.unified_df)\n\n        # Rename columns based on mapping from excel_name to name\n        column_mapping = self._build_column_mapping()\n        # Create a mapping dict with only the columns that exist in the dataframe\n        actual_mapping = {col: column_mapping[col] for col in self.unified_df.columns \n                         if col in column_mapping}\n\n        if actual_mapping:\n            self.unified_df = self.unified_df.rename(columns=actual_mapping)\n            mapped_cols = \", \".join([f\"{old} \u2192 {new}\" for old, new in actual_mapping.items()])\n            messages.append(f\"Renamed columns: {mapped_cols}\")\n\n        # Good place for a breakpoint to inspect self.unified_df\n        summary = \"\\n\".join(messages)\n        return True, f\"Successfully transformed and joined sheets:\\n{summary}\"\n\n    except Exception as e:\n        return False, f\"Error processing sheets: {str(e)}\"\n</code></pre>"},{"location":"api/models/#bosques_app.models.data_model.DataModel.get_summary","title":"<code>get_summary()</code>","text":"<p>Get summary of loaded data</p> Source code in <code>src\\bosques_app\\models\\data_model.py</code> <pre><code>def get_summary(self) -&gt; str:\n    \"\"\"Get summary of loaded data\"\"\"\n    if not self.data:\n        return \"No data loaded\"\n\n    summary = [f\"File: {self.filename}\"]\n    summary.append(f\"Number of sheets: {len(self.sheet_names)}\")\n    summary.append(\"\\nAvailable sheets:\")\n\n    for name, df in self.data.items():\n        summary.append(f\"\\n{name}:\")\n        summary.append(f\"- Rows: {df.shape[0]}\")\n        summary.append(f\"- Columns: {df.shape[1]}\")\n        summary.append(f\"- Columns: {', '.join(df.columns)}\")\n\n    return \"\\n\".join(summary)\n</code></pre>"},{"location":"codebase/MkDocs%20Guide/","title":"Complete Guide to MkDocs for Your Forest Dashboard","text":"<p>I've set up a basic MkDocs documentation structure for your Forest Dashboard application. Here's a detailed explanation of how it works and how to customize it further:</p>"},{"location":"codebase/MkDocs%20Guide/#understanding-your-mkdocs-setup","title":"Understanding Your MkDocs Setup","text":""},{"location":"codebase/MkDocs%20Guide/#1-configuration-mkdocsyml","title":"1. Configuration (mkdocs.yml)","text":"<p>The\u00a0<code>mkdocs.yml</code>\u00a0file I created controls all aspects of your documentation:</p> <ul> <li>Theme settings: Using Material theme with a green color scheme</li> <li>Navigation structure: Organized into User Guide, Developer Guide, API Reference, etc.</li> <li>Extensions: Added markdown extensions for admonitions, code highlighting, etc.</li> <li>Plugins: Configured mkdocstrings for automatic API documentation</li> </ul> <p>You can customize this file to change colors, features, and organization.</p>"},{"location":"codebase/MkDocs%20Guide/#2-documentation-structure","title":"2. Documentation Structure","text":"<pre><code>docs/ \n\u251c\u2500\u2500 index.md                  # Home page \n\u251c\u2500\u2500 user-guide/               # End-user documentation \n\u2502   \u2514\u2500\u2500 getting-started.md    # How to use the application \n\u251c\u2500\u2500 developer-guide/          # Documentation for developers \n\u2502   \u2514\u2500\u2500 architecture.md       # System architecture overview \n\u251c\u2500\u2500 api/                      # Auto-generated API documentation \n\u2502   \u2514\u2500\u2500 models.md             # Documentation for model classes \n\u2514\u2500\u2500 assets/                   # Images and other assets     \n    \u2514\u2500\u2500 images/               # Screenshots, diagrams, etc.`\n</code></pre>"},{"location":"codebase/MkDocs%20Guide/#3-how-mkdocstrings-works","title":"3. How mkdocstrings Works","text":"<p>The magic of mkdocstrings is in the API documentation files. For example, in\u00a0<code>docs/api/models.md</code>:</p> <pre><code>::: bosques_app.models.plot_model.PlotModel\n    handler: python\n    selection:\n      members:\n        - update_plot\n        - _create_scatter_plot\n    rendering:\n      show_root_heading: true\n      show_source: true\n</code></pre> <p>This block:</p> <ol> <li>Automatically extracts documentation from your\u00a0<code>PlotModel</code>\u00a0class</li> <li>Shows only the specified methods (<code>update_plot</code>,\u00a0<code>_create_scatter_plot</code>)</li> <li>Includes source code and proper headings</li> </ol> <p>For this to work, your code should have Google-style docstrings:</p> <pre><code>def update_plot(self, grammar_state):\n    \"\"\"Updates the plot based on the grammar state.\n\n    Args:\n        grammar_state: Dictionary containing the current grammar of graphics state\n            with mappings for x, y, color, etc.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If required mappings are missing\n    \"\"\"\n</code></pre>"},{"location":"codebase/MkDocs%20Guide/#how-to-use-your-documentation","title":"How to Use Your Documentation","text":""},{"location":"codebase/MkDocs%20Guide/#local-development","title":"Local Development","text":"<ol> <li>Start the server: Run\u00a0<code>mkdocs serve</code>\u00a0in your project directory</li> <li>View documentation: Open http://localhost:8000 in your browser</li> <li>Edit files: Changes are automatically reflected in real-time</li> </ol>"},{"location":"codebase/MkDocs%20Guide/#adding-new-pages","title":"Adding New Pages","text":"<ol> <li>Create a new\u00a0<code>.md</code>\u00a0file in the appropriate directory</li> <li>Add it to the\u00a0<code>nav</code>\u00a0section in\u00a0<code>mkdocs.yml</code></li> </ol>"},{"location":"codebase/MkDocs%20Guide/#adding-screenshots","title":"Adding Screenshots","text":"<ol> <li>Take screenshots of your application</li> <li>Save them in\u00a0<code>docs/assets/images/</code></li> <li>Reference them in your markdown:\u00a0<code>![Description](../assets/images/screenshot.png)</code></li> </ol>"},{"location":"codebase/MkDocs%20Guide/#publishing-to-github-pages","title":"Publishing to GitHub Pages","text":"<p>When you're ready to publish:</p> <p>bash</p> <p>CopyInsert in Terminal</p> <p><code>mkdocs gh-deploy</code></p> <p>This builds your site and pushes it to the\u00a0<code>gh-pages</code>\u00a0branch of your GitHub repository, making it available at\u00a0<code>https://yourusername.github.io/your-repo-name/</code>.</p>"},{"location":"codebase/MkDocs%20Guide/#best-practices-for-documentation","title":"Best Practices for Documentation","text":"<ol> <li>Keep it updated: Update documentation as you change code</li> <li>Use examples: Include code examples and screenshots</li> <li>Think of your audience: Write different sections for users vs. developers</li> <li>Be consistent: Use the same terminology throughout</li> <li>Include troubleshooting: Add common issues and solutions</li> </ol>"},{"location":"codebase/MkDocs%20Guide/#next-steps","title":"Next Steps","text":"<ol> <li>Add real screenshots\u00a0of your Forest Dashboard application</li> <li>Complete the remaining pages\u00a0in the navigation structure</li> <li>Add proper docstrings\u00a0to your code if they're missing</li> <li>Customize the theme\u00a0to match your application's style</li> <li>Set up GitHub Pages\u00a0for public hosting</li> </ol> <p>Would you like me to help with any specific aspect of your documentation, such as improving docstrings in your code or creating additional documentation pages?</p>"},{"location":"codebase/data%20flow/","title":"Data flow","text":"<p>[!INFO] In essence:</p> <ul> <li>The UI events are handled by the Controller</li> <li>The actual data loading and storage is handled by the Model</li> <li>The data is stored as pandas DataFrames in a dictionary</li> <li>The View is updated through the logger and status bar</li> </ul> <ol> <li> <p>User Action:</p> <ul> <li>User clicks the \"Load\" button in the UI</li> <li> <p>Controller Layer\u00a0(<code>MainController._on_load_button_clicked</code>):</p> </li> <li> <p>Opens a QFileDialog to let user select an Excel file</p> </li> <li>Logs \"Loading Excel file...\" using loguru</li> <li>Calls\u00a0<code>data_model.load_excel(filename)</code></li> <li>Updates UI based on result:<ul> <li>Success: Shows styled message in status bar + logs summary</li> <li>Error: Clears status bar + logs error</li> </ul> </li> <li> <p>Model Layer\u00a0(<code>DataModel.load_excel</code>):</p> </li> <li> <p>Creates a pandas ExcelFile object</p> </li> <li>Gets list of sheet names</li> <li>Reads all sheets into pandas DataFrames</li> <li>Stores data in the model's attributes: <pre><code>self.data: Dict[str, pd.DataFrame] = {}  # Key: sheet name, Value: DataFrame\nself.filename: str = filename\nself.sheet_names: List[str] = excel_file.sheet_names\n</code></pre></li> <li>Calls\u00a0<code>get_summary()</code>\u00a0to generate a detailed summary</li> <li>Returns (True, summary) on success or (False, error_message) on failure</li> <li> <p>Data Storage: The data is held in the\u00a0<code>DataModel</code>\u00a0class in three main attributes:</p> </li> <li> <p><code>self.data</code>: A dictionary where:</p> <ul> <li>Keys are sheet names (strings)</li> <li>Values are pandas DataFrames containing the sheet data</li> </ul> </li> <li><code>self.filename</code>: The path to the loaded Excel file</li> <li><code>self.sheet_names</code>: List of sheet names in the file</li> <li> <p>Summary Generation\u00a0(<code>DataModel.get_summary</code>): For each sheet, collects and formats:</p> </li> <li> <p>Number of rows and columns</p> </li> <li>For each column:<ul> <li>Data type</li> <li>Number of unique values</li> <li>Number of null values</li> </ul> </li> </ul> </li> </ol>","tags":["data-management","excel-file-loading-and-processing","pandas-data-frames-storage","software-development","ui-events-handling"]},{"location":"codebase/general%20flow/","title":"Forest Data Analysis Application Flow","text":"","tags":["application-flow","data-management","error-handling","software-development","ui-implementation","visualization"]},{"location":"codebase/general%20flow/#1-application-initialization","title":"1. Application Initialization","text":"<ol> <li>Entry Point (<code>main.py</code>)</li> <li>Creates QApplication instance</li> <li>Instantiates main Application class</li> <li> <p>Starts Qt event loop</p> </li> <li> <p>Application Setup (<code>app.py</code>)</p> </li> <li>Creates main window (View)</li> <li>Initializes logging system</li> <li>Loads application configuration</li> <li>Creates data model</li> <li>Creates main controller</li> <li> <p>Connects components together</p> </li> <li> <p>Component Initialization</p> </li> <li> <p>View Layer (<code>main_window.py</code>)</p> <ul> <li>Loads UI from .ui file</li> <li>Sets up plot widget</li> <li>Initializes status bar</li> <li>Centers window on screen</li> </ul> </li> <li> <p>Model Layer</p> <ul> <li>Initializes data structures (<code>data_model.py</code>)</li> <li>Sets up data validation rules test</li> <li>Prepares storage containers</li> </ul> </li> <li> <p>Controller Layer (<code>main_controller.py</code>)</p> <ul> <li>Connects UI signals to handlers</li> <li>Sets up event processing</li> <li>Initializes UI state</li> </ul> </li> </ol>","tags":["application-flow","data-management","error-handling","software-development","ui-implementation","visualization"]},{"location":"codebase/general%20flow/#2-data-management-flow","title":"2. Data Management Flow","text":"<p>![[data flow]]</p>","tags":["application-flow","data-management","error-handling","software-development","ui-implementation","visualization"]},{"location":"codebase/general%20flow/#3-analysis-and-visualization-flow","title":"3. Analysis and Visualization Flow","text":"<ol> <li>Data Selection</li> <li>Sheet selection</li> <li>Variable selection</li> <li> <p>Filter application</p> </li> <li> <p>Analysis Processing</p> </li> <li>Statistical calculations</li> <li>Data transformations</li> <li> <p>Result generation</p> </li> <li> <p>Visualization</p> </li> <li>Plot generation</li> <li>Graph updates</li> <li>Visual feedback</li> </ol>","tags":["application-flow","data-management","error-handling","software-development","ui-implementation","visualization"]},{"location":"codebase/general%20flow/#4-user-interaction-flow","title":"4. User Interaction Flow","text":"<ol> <li>UI Events</li> <li>Button clicks</li> <li>Menu selections</li> <li> <p>Drag and drop operations</p> </li> <li> <p>Feedback System</p> </li> <li>Status bar updates</li> <li>Log messages</li> <li>Error handling</li> <li>Progress indicators</li> </ol>","tags":["application-flow","data-management","error-handling","software-development","ui-implementation","visualization"]},{"location":"codebase/general%20flow/#5-error-handling-and-logging","title":"5. Error Handling and Logging","text":"<ol> <li>Error Management</li> <li>Exception catching</li> <li>User notification</li> <li> <p>Recovery procedures</p> </li> <li> <p>Logging System</p> </li> <li>Application events</li> <li>User actions</li> <li>System status</li> <li>Debug information</li> </ol>","tags":["application-flow","data-management","error-handling","software-development","ui-implementation","visualization"]},{"location":"codebase/general%20flow/#6-application-state-management","title":"6. Application State Management","text":"<ol> <li>State Tracking</li> <li>Data loaded status</li> <li>Analysis status</li> <li> <p>UI state</p> </li> <li> <p>Configuration Management</p> </li> <li>Settings loading</li> <li>User preferences</li> <li>System configuration</li> </ol>","tags":["application-flow","data-management","error-handling","software-development","ui-implementation","visualization"]},{"location":"codebase/general%20flow/#7-application-shutdown","title":"7. Application Shutdown","text":"<ol> <li>Cleanup</li> <li>Resource release</li> <li>State saving</li> <li> <p>Connection closing</p> </li> <li> <p>Exit Procedures</p> </li> <li>User confirmation</li> <li>Data saving</li> <li>Application termination</li> </ol>","tags":["application-flow","data-management","error-handling","software-development","ui-implementation","visualization"]},{"location":"","title":"Forest Dashboard Documentation","text":"<p>Welcome to the Forest Dashboard documentation. This application provides tools for analyzing and visualizing forest data.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Data Loading: Import Excel files with forest measurement data</li> <li>Interactive Visualization: Create customizable plots with:</li> <li>Zooming and panning functionality</li> <li>Tooltips showing data point information</li> <li>Legend toggling to show/hide data series</li> <li>Data Tables: View the data behind your visualizations</li> <li>Grammar of Graphics: Build plots by mapping variables to visual properties</li> <li>Task Queue: Save and manage multiple analysis tasks</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Install the application following the installation guide</li> <li>Load your forest data using the \"Load\" button</li> <li>Select variables in the Graph Builder tab</li> <li>Create visualizations by dragging variables to the appropriate frames</li> <li>Explore your data using the interactive plot features</li> </ol>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>User Guide: Instructions for using the application</li> <li>Developer Guide: Information for developers</li> <li>API Reference: Detailed documentation of the code</li> </ul>"},{"location":"#screenshots","title":"Screenshots","text":""},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the License page for details.</p>"},{"location":"developer-guide/architecture/","title":"Forest Dashboard Architecture","text":"<p>This document provides an overview of the Forest Dashboard application architecture for developers who want to understand, modify, or extend the codebase.</p>"},{"location":"developer-guide/architecture/#overview","title":"Overview","text":"<p>The Forest Dashboard application follows the Model-View-Controller (MVC) architectural pattern:</p> <ul> <li>Models: Handle data processing, storage, and business logic</li> <li>Views: Define the UI components (using PyQt6)</li> <li>Controllers: Connect models and views, handling user interactions</li> </ul>"},{"location":"developer-guide/architecture/#project-structure","title":"Project Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 bosques_app/\n\u2502   \u251c\u2500\u2500 config/           # Configuration files and settings\n\u2502   \u251c\u2500\u2500 controllers/      # Controller classes\n\u2502   \u251c\u2500\u2500 models/           # Model classes\n\u2502   \u251c\u2500\u2500 resources/        # Images, icons, and other resources\n\u2502   \u251c\u2500\u2500 ui/               # UI definition files (.ui)\n\u2502   \u2514\u2500\u2500 utils/            # Utility functions and classes\n\u2514\u2500\u2500 main.py               # Application entry point\n</code></pre>"},{"location":"developer-guide/architecture/#key-components","title":"Key Components","text":""},{"location":"developer-guide/architecture/#models","title":"Models","text":"<ul> <li>DataModel: Handles loading and processing Excel data</li> <li>PlotModel: Creates and manages plots based on grammar of graphics</li> <li>GrammarModel: Manages the state of the grammar of graphics</li> <li>VariablesModel: Handles variable selection and management</li> <li>MapModel: Manages map visualization</li> <li>TaskQueueModel: Handles task queue management</li> </ul>"},{"location":"developer-guide/architecture/#controllers","title":"Controllers","text":"<ul> <li>MainController: Primary controller that coordinates all components</li> <li>DialogControllers: Handle various dialog interactions</li> </ul>"},{"location":"developer-guide/architecture/#views","title":"Views","text":"<ul> <li>MainWindow: Primary application window defined in main_window.ui</li> <li>Dialogs: Various dialog windows for specific interactions</li> </ul>"},{"location":"developer-guide/architecture/#data-flow","title":"Data Flow","text":"<ol> <li>User loads an Excel file via the UI</li> <li>MainController passes the file to DataModel</li> <li>DataModel processes the file and creates a unified dataframe</li> <li>User selects variables and maps them to visual properties</li> <li>GrammarModel updates its state based on user selections</li> <li>PlotModel creates visualizations based on the grammar state and data</li> <li>MainController updates the UI to display the visualizations and data tables</li> </ol>"},{"location":"developer-guide/architecture/#interactive-features","title":"Interactive Features","text":"<p>The application includes several interactive features:</p> <ol> <li>Zooming and Panning: Implemented in PlotModel using PyQtGraph's capabilities</li> <li>Tooltips: Custom implementation using QToolTip to display data point information</li> <li>Legend Toggling: Implemented in PlotModel to show/hide data series</li> <li>Data Tables: Displays the subset of data used in plots using a custom DataTableModel</li> </ol>"},{"location":"developer-guide/architecture/#extension-points","title":"Extension Points","text":"<p>When extending the application, consider these key integration points:</p> <ol> <li>Adding New Plot Types: Extend PlotModel with new plot creation methods</li> <li>Supporting New Data Sources: Extend DataModel with new data loading methods</li> <li>Adding UI Components: Modify main_window.ui and update MainController</li> <li>Adding New Analysis Features: Create new models and integrate with MainController</li> </ol>"},{"location":"developer-guide/architecture/#technology-stack","title":"Technology Stack","text":"<ul> <li>PyQt6: UI framework</li> <li>PyQtGraph: Interactive plotting library</li> <li>pandas: Data manipulation and analysis</li> <li>numpy: Numerical computations</li> <li>Markdown: Documentation formatting</li> </ul>"},{"location":"developer-guide/architecture/#development-guidelines","title":"Development Guidelines","text":"<ol> <li>Docstrings: Use Google-style docstrings for all classes and methods</li> <li>Logging: Use the Logger class for all logging needs</li> <li>Error Handling: Use try-except blocks with appropriate error messages</li> <li>UI Updates: Make UI changes in Qt Designer when possible</li> <li>Testing: Write tests for new functionality</li> </ol>"},{"location":"developer-guide/architecture/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"developer-guide/architecture/#adding-a-new-plot-type","title":"Adding a New Plot Type","text":"<ol> <li>Add a new option to the plot type dropdown in main_window.ui</li> <li>Create a new plot creation method in PlotModel</li> <li>Update the update_plot method in PlotModel to call your new method</li> </ol>"},{"location":"developer-guide/architecture/#supporting-a-new-data-format","title":"Supporting a New Data Format","text":"<ol> <li>Add a new data loading method to DataModel</li> <li>Update the UI to support selecting the new format</li> <li>Modify create_unified_dataframe to handle the new format</li> </ol>"},{"location":"user-guide/getting-started/","title":"Getting Started with Forest Dashboard","text":"<p>This guide will help you get up and running with the Forest Dashboard application.</p>"},{"location":"user-guide/getting-started/#application-overview","title":"Application Overview","text":"<p>The Forest Dashboard provides a comprehensive interface for analyzing forest data with the following key components:</p> <ol> <li>Data Loading: Import Excel files containing forest measurements</li> <li>Variable Selection: Choose variables for analysis from your dataset</li> <li>Graph Builder: Create visualizations using a grammar of graphics approach</li> <li>Interactive Plots: Explore data with zooming, panning, and tooltips</li> <li>Data Tables: View the tabular data behind your visualizations</li> </ol>"},{"location":"user-guide/getting-started/#basic-workflow","title":"Basic Workflow","text":""},{"location":"user-guide/getting-started/#1-loading-data","title":"1. Loading Data","text":"<ol> <li>Click the Load button in the top-left corner</li> <li>Select an Excel file (.xlsx or .xls) containing your forest data</li> <li>Choose which sheets to include in your analysis</li> <li>The application will combine the selected sheets into a unified dataset</li> </ol>"},{"location":"user-guide/getting-started/#2-building-visualizations","title":"2. Building Visualizations","text":"<p>The Graph Builder tab uses a grammar of graphics approach:</p> <ol> <li>Select variables from the tree view on the left</li> <li>Drag variables to the appropriate frames:</li> <li>X-axis: Horizontal axis variable (often time or categories)</li> <li>Y-axis: Vertical axis variable (measurements or counts)</li> <li>Color: Variable to map to different colors</li> <li>Size: Variable to map to point sizes</li> <li>Shape: Variable to map to different shapes</li> <li> <p>Alpha: Variable to map to transparency</p> </li> <li> <p>Choose a plot type from the dropdown menu:</p> </li> <li>Scatter plot</li> <li>Line plot</li> <li>Bar plot</li> </ol>"},{"location":"user-guide/getting-started/#3-exploring-your-data","title":"3. Exploring Your Data","text":"<p>Once your plot is created, you can:</p> <ul> <li>Zoom: Use the mouse wheel or draw a rectangle to zoom in</li> <li>Pan: Click and drag to move around the plot</li> <li>View Tooltips: Hover over data points to see detailed information</li> <li>Toggle Series: Click on legend items to show/hide data series</li> <li>View Data Table: Switch to the Table tab to see the data behind your plot</li> </ul>"},{"location":"user-guide/getting-started/#4-saving-your-analysis","title":"4. Saving Your Analysis","text":"<ul> <li>Click the Add Task button to save your current visualization setup</li> <li>Build a queue of analysis tasks to run in sequence</li> <li>Save your entire analysis configuration for future sessions</li> </ul>"},{"location":"user-guide/getting-started/#interactive-features","title":"Interactive Features","text":"<p>The Forest Dashboard includes several interactive features to enhance your data exploration:</p> <ul> <li>Zooming and panning: Navigate through your data at different scales</li> <li>Tooltips: Hover over data points to see detailed information</li> <li>Legend toggling: Show or hide specific data series by clicking on legend items</li> <li>Data tables: View the exact values being plotted in a tabular format</li> </ul> <p>These features allow for a more intuitive and comprehensive analysis of your forest data.</p>"},{"location":"es/","title":"Documentaci\u00f3n del Panel de Control Forestal","text":"<p>Bienvenido a la documentaci\u00f3n del Panel de Control Forestal. Esta aplicaci\u00f3n proporciona herramientas para analizar y visualizar datos forestales.</p>"},{"location":"es/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Carga de Datos: Importaci\u00f3n de archivos Excel con datos de mediciones forestales</li> <li>Visualizaci\u00f3n Interactiva: Creaci\u00f3n de gr\u00e1ficos personalizables con:</li> <li>Funcionalidad de zoom y desplazamiento</li> <li>Informaci\u00f3n emergente que muestra informaci\u00f3n de puntos de datos</li> <li>Activaci\u00f3n/desactivaci\u00f3n de leyendas para mostrar/ocultar series de datos</li> <li>Tablas de Datos: Visualizaci\u00f3n de los datos detr\u00e1s de sus visualizaciones</li> <li>Gram\u00e1tica de Gr\u00e1ficos: Construcci\u00f3n de gr\u00e1ficos asignando variables a propiedades visuales</li> <li>Cola de Tareas: Guardar y gestionar m\u00faltiples tareas de an\u00e1lisis</li> </ul>"},{"location":"es/#inicio-rapido","title":"Inicio R\u00e1pido","text":"<ol> <li>Instale la aplicaci\u00f3n siguiendo la gu\u00eda de instalaci\u00f3n</li> <li>Cargue sus datos forestales utilizando el bot\u00f3n \"Cargar\"</li> <li>Seleccione variables en la pesta\u00f1a Creador de Gr\u00e1ficos</li> <li>Cree visualizaciones arrastrando variables a los marcos apropiados</li> <li>Explore sus datos utilizando las funciones interactivas del gr\u00e1fico</li> </ol>"},{"location":"es/#secciones-de-documentacion","title":"Secciones de Documentaci\u00f3n","text":"<ul> <li>Gu\u00eda del Usuario: Instrucciones para usar la aplicaci\u00f3n</li> <li>Gu\u00eda del Desarrollador: Informaci\u00f3n para desarrolladores</li> <li>Referencia de la API: Documentaci\u00f3n detallada del c\u00f3digo</li> </ul>"},{"location":"es/#capturas-de-pantalla","title":"Capturas de Pantalla","text":""},{"location":"es/#licencia","title":"Licencia","text":"<p>Este proyecto est\u00e1 licenciado bajo la Licencia MIT - vea la p\u00e1gina de Licencia para m\u00e1s detalles.</p>"},{"location":"es/user-guide/getting-started/","title":"Primeros Pasos con el Panel de Control Forestal","text":"<p>Esta gu\u00eda le ayudar\u00e1 a comenzar a utilizar la aplicaci\u00f3n Panel de Control Forestal.</p>"},{"location":"es/user-guide/getting-started/#descripcion-general-de-la-aplicacion","title":"Descripci\u00f3n General de la Aplicaci\u00f3n","text":"<p>El Panel de Control Forestal proporciona una interfaz completa para analizar datos forestales con los siguientes componentes clave:</p> <ol> <li>Carga de Datos: Importaci\u00f3n de archivos Excel que contienen mediciones forestales</li> <li>Selecci\u00f3n de Variables: Elecci\u00f3n de variables para an\u00e1lisis desde su conjunto de datos</li> <li>Creador de Gr\u00e1ficos: Creaci\u00f3n de visualizaciones utilizando un enfoque de gram\u00e1tica de gr\u00e1ficos</li> <li>Gr\u00e1ficos Interactivos: Exploraci\u00f3n de datos con zoom, desplazamiento y tooltips</li> <li>Tablas de Datos: Visualizaci\u00f3n de los datos tabulares detr\u00e1s de sus visualizaciones</li> </ol>"},{"location":"es/user-guide/getting-started/#flujo-de-trabajo-basico","title":"Flujo de Trabajo B\u00e1sico","text":""},{"location":"es/user-guide/getting-started/#1-carga-de-datos","title":"1. Carga de Datos","text":"<ol> <li>Haga clic en el bot\u00f3n Cargar en la esquina superior izquierda</li> <li>Seleccione un archivo Excel (.xlsx o .xls) que contenga sus datos forestales</li> <li>Elija qu\u00e9 hojas incluir en su an\u00e1lisis</li> <li>La aplicaci\u00f3n combinar\u00e1 las hojas seleccionadas en un conjunto de datos unificado</li> </ol>"},{"location":"es/user-guide/getting-started/#2-construccion-de-visualizaciones","title":"2. Construcci\u00f3n de Visualizaciones","text":"<p>La pesta\u00f1a Creador de Gr\u00e1ficos utiliza un enfoque de gram\u00e1tica de gr\u00e1ficos:</p> <ol> <li>Seleccione variables desde la vista de \u00e1rbol a la izquierda</li> <li>Arrastre variables a los marcos apropiados:</li> <li>Eje X: Variable del eje horizontal (a menudo tiempo o categor\u00edas)</li> <li>Eje Y: Variable del eje vertical (mediciones o conteos)</li> <li>Color: Variable para mapear a diferentes colores</li> <li>Tama\u00f1o: Variable para mapear a tama\u00f1os de puntos</li> <li>Forma: Variable para mapear a diferentes formas</li> <li> <p>Alfa: Variable para mapear a transparencia</p> </li> <li> <p>Elija un tipo de gr\u00e1fico desde el men\u00fa desplegable:</p> </li> <li>Gr\u00e1fico de dispersi\u00f3n</li> <li>Gr\u00e1fico de l\u00edneas</li> <li>Gr\u00e1fico de barras</li> </ol>"},{"location":"es/user-guide/getting-started/#3-exploracion-de-sus-datos","title":"3. Exploraci\u00f3n de Sus Datos","text":"<p>Una vez que su gr\u00e1fico es creado, puede:</p> <ul> <li>Zoom: Use la rueda del rat\u00f3n o dibuje un rect\u00e1ngulo para acercar</li> <li>Desplazamiento: Haga clic y arrastre para moverse por el gr\u00e1fico</li> <li>Ver Tooltips: Pase el cursor sobre puntos de datos para ver informaci\u00f3n detallada</li> <li>Alternar Series: Haga clic en elementos de la leyenda para mostrar/ocultar series de datos</li> <li>Ver Tabla de Datos: Cambie a la pesta\u00f1a Tabla para ver los datos detr\u00e1s de su gr\u00e1fico</li> </ul>"},{"location":"es/user-guide/getting-started/#4-guardado-de-su-analisis","title":"4. Guardado de Su An\u00e1lisis","text":"<ul> <li>Haga clic en el bot\u00f3n A\u00f1adir Tarea para guardar su configuraci\u00f3n de visualizaci\u00f3n actual</li> <li>Construya una cola de tareas de an\u00e1lisis para ejecutar en secuencia</li> <li>Guarde toda su configuraci\u00f3n de an\u00e1lisis para sesiones futuras</li> </ul>"},{"location":"es/user-guide/getting-started/#caracteristicas-interactivas","title":"Caracter\u00edsticas Interactivas","text":"<p>El Panel de Control Forestal incluye varias caracter\u00edsticas interactivas para mejorar su exploraci\u00f3n de datos:</p> <ul> <li>Zoom y desplazamiento: Navegue a trav\u00e9s de sus datos a diferentes escalas</li> <li>Tooltips: Pase el cursor sobre puntos de datos para ver informaci\u00f3n detallada</li> <li>Alternancia de leyenda: Muestre u oculte series de datos espec\u00edficas haciendo clic en elementos de la leyenda</li> <li>Tablas de datos: Vea los valores exactos que se est\u00e1n graficando en formato tabular</li> </ul> <p>Estas caracter\u00edsticas permiten un an\u00e1lisis m\u00e1s intuitivo y completo de sus datos forestales.</p>"}]}